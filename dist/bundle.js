!function(e){var t={};function r(n){if(t[n])return t[n].exports;var a=t[n]={i:n,l:!1,exports:{}};return e[n].call(a.exports,a,a.exports,r),a.l=!0,a.exports}r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)r.d(n,a,function(t){return e[t]}.bind(null,a));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(1);window.addEventListener("load",(function(){document.getElementById("input").addEventListener("keyup",e=>{(e=>{const t=document.getElementById("input"),r=document.getElementById("registers"),a=document.getElementById("stack");try{const e=n.run(t.value);a.innerHTML="",e.interpreter.stack.reverse().forEach(e=>{const t=document.createElement("div");t.textContent=e.value,t.classList.add("stack-item"),t.classList.add("token--"+typeof e.value),a.appendChild(t)}),r.innerHTML="",Object.keys(e.memory).forEach(t=>{const n=document.createElement("div");n.className="register";const a=document.createElement("div");a.className="register-label",a.textContent=""+t;const o=document.createElement("div");o.classList.add("register-value"),o.classList.add("token--"+typeof e.memory[t].value),o.textContent=""+e.memory[t].value,n.appendChild(a),n.appendChild(o),r.appendChild(n)})}catch(e){a.textContent=e}})()},!1)}),!1)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.run=t.Interpreter=t.Operator=t.Tokenizer=t.Token=t.UnknownOperator=t.InputExhausted=void 0;class n extends Error{}t.InputExhausted=n;class a extends Error{}function o(e){return e&&Symbol.iterator in e}t.UnknownOperator=a;class u{constructor({type:e,value:t}){this.type=e,this.value=t}clone(){const{type:e,value:t}=this;return new u({type:e,value:t})}}t.Token=u;class l{constructor(e){this.ruleSet=e}tokenizeParen(e){let t=0,r=0;do{if(r>=e.length)throw new Error("Unmatched parentheses");"("===e[r]?++t:")"===e[r]&&--t,++r}while(t>0);const n=e.slice(1,r-1);return[new u({type:"symbol",value:n}),e.slice(r)]}*tokenize(e){for(;e.length>0;){if("("===e[0]){const[t,r]=this.tokenizeParen(e);e=r,yield t;continue}let t=0,r=null,n=null;for(let[a,o]of this.ruleSet){const u=a.exec(e);if(!u||0!==u.index)continue;const l=u[0].length;l>t&&(t=l,r=u,n=o)}if(0===t)throw new Error("Unrecognized grammar starting here: "+e.slice(0,32));const a=n(r);a&&(yield a),e=e.slice(t)}}}t.Tokenizer=l;class s{constructor(e,t=!1,r=e.length){this.func=e,this.arity=r,this.rest=t,this.interpreter=null}collectArgs(e,t){const r=[];for(let n=0;n<this.arity;++n){if(0===e.stack.length)throw new Error(`Expected ${this.arity} operands for operator "${t}"`);r.push(e.stack.pop())}if(this.rest)for(;e.stack.length>0;)r.push(e.stack.pop());return r}pushResult(e,t){o(t)?e.stack.push(...t):t&&e.stack.push(t)}invoke(e,t){const r=this.collectArgs(e,t);this.interpreter=e;const n=this.func.apply(this,r);return this.interpreter=null,this.pushResult(e,n),n}}t.Operator=s;class i{constructor(e,t){this.stack=[],this.opTable=e,this.tokenizer=t}getOp(e){if(e in this.opTable)return this.opTable[e];throw new Error(`"${e}" is not an operator`)}evaluate(e){const t=this.tokenizer.tokenize(e);for(let e of t)if("symbol"===e.type&&this.stack.push(e),"operator"===e.type){this.getOp(e.value).invoke(this,e.value)}if(0!==this.stack.length)return this.stack[this.stack.length-1]}}t.Interpreter=i,t.run=function(e){const t={},r=e=>new s((...t)=>new u({type:"symbol",value:e(...t.reverse())}),!1,e.length),n={"+":r((e,t)=>e.value+t.value),"-":r((e,t)=>e.value-t.value),"*":r((e,t)=>e.value*t.value),"/":r((e,t)=>e.value/t.value),"^":r((e,t)=>e.value**t.value),"%":r((e,t)=>e.value%t.value),xor:r((e,t)=>e.value^t.value),"==":r((e,t)=>e.value===t.value),"<":r((e,t)=>e.value<t.value),">":r((e,t)=>e.value>t.value),"<=":r((e,t)=>e.value<=t.value),">=":r((e,t)=>e.value>=t.value),not:r(e=>!e.value),and:r((e,t)=>e.value&&t.value),or:r((e,t)=>e.value||t.value),if:new s((function(e,t,r){const n=this.interpreter.evaluate(e.value);this.interpreter.stack.pop(),n&&n.value?this.interpreter.evaluate(t.value):this.interpreter.evaluate(r.value)})),print:new s(e=>{console.log(e.value)}),dup:new s(e=>[e,e.clone()]),swap:new s((e,t)=>[e,t]),pop:new s(e=>{}),clear:new s((...e)=>{},!0),reduce:new s((function(e,t,...r){const n=this.interpreter.getOp(e.value);if(2!==n.arity)throw new Error(`A reduce operator must accept 2 operands; "${e.value}" requires ${n.arity}`);this.interpreter.stack.push(t);for(let t of r){this.interpreter.stack.push(t);if(o(n.invoke(this.interpreter,e.value)))throw new Error(`Reduce operator "${e.value}" produced more than one return value`)}return this.interpreter.stack.pop()}),!0),map:new s((function(e,...t){const r=this.interpreter.getOp(e.value);if(1!==r.arity)throw new Error(`A map operator must accept 1 operand; "${e.value}" requires ${r.arity}`);for(;t.length>0;){const n=t.pop();this.interpreter.stack.push(n);if(o(r.invoke(this.interpreter,e.value)))throw new Error(`Map operator "${e.value}" produced more than one return value`)}return this.interpreter.stack.pop()}),!0),filter:new s((function(e,...t){const r=this.interpreter.getOp(e.value);if(1!==r.arity)throw new Error(`A filter operator must accept 1 operand; "${e.value}" requires ${r.arity}`);for(;t.length>0;){const n=t.pop();this.interpreter.stack.push(n),r.invoke(this.interpreter,e.value);const a=this.interpreter.stack.pop();if(o(a))throw new Error(`Filter operator "${e.value}" produced more than one return value`);a.value&&this.interpreter.stack.push(n)}return this.interpreter.stack.pop()}),!0),range:new s((function*(e,t,r){if("number"!=typeof e.value||"number"!=typeof t.value||"number"!=typeof r.value)throw new Error("range operator expects numerical arguments");const n=Math.sign(t.value-e.value),a=Math.abs(t.value-e.value)/r.value;let o=e.value;for(let e=0;e<a;++e)yield new u({type:"symbol",value:o}),o+=n*r.value})),"alias-op":new s((e,t)=>{n[e.value]=n[t.value]}),"define-op":new s((e,t,r)=>{n[r.value]=new s((function(...t){this.interpreter.stack.push(...t),this.interpreter.evaluate(e.value)}),!1,t.value)}),"del-op":new s(e=>{delete n[e.value]}),store:new s((e,r)=>{t[e.value]=r}),load:new s(e=>t[e.value]),delete:new s(e=>{delete t[e.value]}),pack:new s((function(){const e=new u({type:"symbol",value:this.interpreter.stack.map(e=>""+e.value).join(" ")});for(;this.interpreter.stack.length;)this.interpreter.stack.pop();return e})),eval:new s((function(e){this.interpreter.evaluate(e.value)}))},a=new l([[/\s+/,e=>{}],[/\/\/.*?$/m,e=>{}],[/\*+[^*]*\*+(?:[^/*][^*]*\*+)*/,e=>{}],[/("|')((?:[^\1\\]|\\.)*?)\1/,e=>{const t=e[2].replace(/\\(.)/g,"$1");return new u({type:"symbol",value:t})}],[/true|false/,e=>new u({type:"symbol",value:"true"===e[0]})],[/[+-]?\d*\.?[0-9]+([eE][+-]?\d+)?/,e=>new u({type:"symbol",value:Number.parseFloat(e[0])})],[/\S+/,e=>{const t=e[0];return new u(t in n?{type:"operator",value:t}:{type:"symbol",value:t})}]]),p=new i(n,a),c=p.evaluate(e);return c?{value:c.value,interpreter:p,memory:t}:{value:void 0,interpreter:p,memory:t}}}]);
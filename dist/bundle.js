!function(e){var t={};function r(a){if(t[a])return t[a].exports;var o=t[a]={i:a,l:!1,exports:{}};return e[a].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=e,r.c=t,r.d=function(e,t,a){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:a})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(r.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(a,o,function(t){return e[t]}.bind(null,o));return a},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const a=r(1);window.addEventListener("load",(function(){document.getElementById("input").addEventListener("keyup",e=>{(e=>{const t=document.getElementById("input"),r=document.getElementById("registers"),o=document.getElementById("stack");try{const e=a.run(t.value);o.innerHTML="",e.interpreter.stack.reverse().forEach(e=>{const t=document.createElement("div");t.textContent=e.value,t.classList.add("stack-item"),t.classList.add("token--"+typeof e.value),o.appendChild(t)}),r.innerHTML="",Object.keys(e.memory).forEach(t=>{const a=document.createElement("div");a.className="register";const o=document.createElement("div");o.className="register-label",o.textContent=""+t;const n=document.createElement("div");n.classList.add("register-value"),n.classList.add("token--"+typeof e.memory[t].value),n.textContent=""+e.memory[t].value,a.appendChild(o),a.appendChild(n),r.appendChild(a)})}catch(e){o.textContent=e}})()},!1)}),!1)},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.run=exports.Interpreter=exports.Operator=exports.Tokenizer=exports.Token=exports.UnknownOperator=exports.InputExhausted=void 0;class InputExhausted extends Error{}exports.InputExhausted=InputExhausted;class UnknownOperator extends Error{}function isIterable(e){return e&&Symbol.iterator in e}exports.UnknownOperator=UnknownOperator;class Token{constructor({type:e,value:t}){this.type=e,this.value=t}clone(){const{type:e,value:t}=this;return new Token({type:e,value:t})}serialize(){return"operator"===this.type?""+this.value:"string"==typeof this.value?`(${this.value})`:""+this.value}}exports.Token=Token;class Tokenizer{constructor(e){this.ruleSet=e}tokenizeParen(e){let t=0,r=0;do{if(r>=e.length)throw new Error("Unmatched parentheses");"("===e[r]?++t:")"===e[r]&&--t,++r}while(t>0);const a=e.slice(1,r-1);return[new Token({type:"symbol",value:a}),e.slice(r)]}*tokenize(e){for(;e.length>0;){if("("===e[0]){const[t,r]=this.tokenizeParen(e);e=r,yield t;continue}let t=0,r=null,a=null;for(let[o,n]of this.ruleSet){const s=o.exec(e);if(!s||0!==s.index)continue;const l=s[0].length;l>t&&(t=l,r=s,a=n)}if(0===t)throw new Error("Unrecognized grammar starting here: "+e.slice(0,32));const o=a(r);o&&(yield o),e=e.slice(t)}}}exports.Tokenizer=Tokenizer;class StackWrapper{constructor(e,t){this.stack=e,this.caller=t.caller}pop({ignoreEmpty:e}={}){if(!this.stack.length){if(e)return;throw new Error(`"${this.caller}" expected another item on the stack, but it was empty.\nLast item was: ${this.last.serialize()}`)}return this.last=this.stack.pop(),this.last}push(...e){this.stack.push(...e)}popArgs(...e){if(this.stack.length<e.length){const t=e.map(e=>`"${e}"`).join(", ");throw new Error(`"${this.caller}" expected at least ${e.length} items on the stack, but only ${this.stack.length} items were present.\nIt expects arguments ${t}.`)}const t={};for(const r of[...e.reverse()])t[r]=this.pop();return t}popAll(){const e=[];for(;this.stack.length;)e.unshift(this.stack.pop());return e}}class Operator{constructor(e,t="none"){this.func=e,this.arity=t,this.interpreter=null}pushResult(e,t){isIterable(t)?e.stack.push(...t):t&&e.stack.push(t)}invoke(e,t){const r=new StackWrapper(e.stack,{caller:t}),a=this.func({stack:r,interpreter:e});return this.pushResult(e,a),a}}exports.Operator=Operator;class Interpreter{constructor(e,t){this.stack=[],this.opTable=e,this.tokenizer=t}getOp(e){if(e in this.opTable)return this.opTable[e];throw new Error(`"${e}" is not an operator`)}evaluate(e){const t=this.tokenizer.tokenize(e);for(const e of t)if("symbol"===e.type&&this.stack.push(e),"operator"===e.type){this.getOp(e.value).invoke(this,e.value)}if(0!==this.stack.length)return this.stack[this.stack.length-1]}}function run(input){const memory={},valueOp=(e,t)=>new Operator(({stack:r})=>new Token({type:"symbol",value:t(r.popArgs(...e))}),e.length),opTable={noop:new Operator(()=>{}),"+":valueOp(["a","b"],({a:e,b:t})=>e.value+t.value),"-":valueOp(["a","b"],({a:e,b:t})=>e.value-t.value),"*":valueOp(["a","b"],({a:e,b:t})=>e.value*t.value),"/":valueOp(["a","b"],({a:e,b:t})=>e.value/t.value),"^":valueOp(["a","b"],({a:e,b:t})=>e.value**t.value),"%":valueOp(["a","b"],({a:e,b:t})=>e.value%t.value),xor:valueOp(["a","b"],({a:e,b:t})=>e.value^t.value),"==":valueOp(["a","b"],({a:e,b:t})=>e.value==t.value),"<":valueOp(["a","b"],({a:e,b:t})=>e.value<t.value),">":valueOp(["a","b"],({a:e,b:t})=>e.value>t.value),">=":valueOp(["a","b"],({a:e,b:t})=>e.value>=t.value),"<=":valueOp(["a","b"],({a:e,b:t})=>e.value<=t.value),not:valueOp(["a"],({a:e})=>!e.value),and:valueOp(["a","b"],({a:e,b:t})=>e.value&&t.value),or:valueOp(["a","b"],({a:e,b:t})=>e.value||t.value),if:new Operator(({stack:e,interpreter:t})=>{const{otherwise:r,then:a,condition:o}=e.popArgs("condition","then","otherwise");t.evaluate(o.value);const n=e.pop();n&&n.value?t.evaluate(a.value):t.evaluate(r.value)}),print:new Operator(({stack:e})=>{console.log(e.pop().value)}),dup:new Operator(({stack:e})=>{const t=e.pop();return[t,t.clone()]}),swap:new Operator(({stack:e})=>{const{a:t,b:r}=e.popArgs("a","b");return[r,t]}),over:new Operator(({stack:e})=>{const{a:t,b:r}=e.popArgs("a","b");return[t,r,t.clone()]}),pick:new Operator(({stack:e})=>{const{a:t,b:r,c:a}=e.popArgs("a","b","c");return[t,r,a,t.clone()]}),pop:new Operator(({stack:e})=>{e.pop({ignoreEmpty:!0})}),clear:new Operator(({stack:e})=>{e.popAll()}),reduce:new Operator(({stack:e,interpreter:t})=>{const{op:r,first:a}=e.popArgs("first","op"),o=e.popAll(),n=t.getOp(r.value);if(2!==n.arity&&"none"!==n.arity)throw new Error(`A reduce operator must accept 2 operands; "${r.value}" requires ${n.arity}`);e.push(a);for(const a of o){e.push(a);if(isIterable(n.invoke(t,r.value)))throw new Error(`Reduce operator "${r.value}" produced more than one return value`)}return e.pop()}),map:new Operator(({stack:e,interpreter:t})=>{const{op:r}=e.popArgs("op"),a=e.popAll(),o=t.getOp(r.value);if(1!==o.arity&&"none"!==o.arity)throw new Error(`A map operator must accept 1 operand; "${r.value}" requires ${o.arity}`);for(const n of a)e.push(n),o.invoke(t,r.value);return e.pop({ignoreEmpty:!0})}),filter:new Operator(({stack:e,interpreter:t})=>{const{op:r}=e.popArgs("op"),a=e.popAll(),o=t.getOp(r.value);if(1!==o.arity&&"none"!==o.arity)throw new Error(`A filter operator must accept 1 operand; "${r.value}" requires ${o.arity}`);for(const n of a){e.push(n),o.invoke(t,r.value);const a=e.pop();if(isIterable(a))throw new Error(`Filter operator "${r.value}" produced more than one return value`);a.value&&e.push(n)}return e.pop()}),range:new Operator(({stack:e})=>{const{step:t,end:r,start:a}=e.popArgs("start","end","step");if("number"!=typeof a.value||"number"!=typeof r.value||"number"!=typeof t.value)throw new Error("range operator expects numerical arguments");const o=Math.sign(r.value-a.value),n=Math.abs(r.value-a.value)/t.value;let s=a.value;for(let r=0;r<n;++r)e.push(new Token({type:"symbol",value:s})),s+=o*t.value}),"alias-op":new Operator(({stack:e})=>{const{a:t,b:r}=e.popArgs("a","b");opTable[r.value]=opTable[t.value]}),"define-op":new Operator(({stack:e,interpreter:t})=>{const{code:r,arity:a,name:o}=e.popArgs("name","arity","code");if("number"!=typeof a.value&&"none"!==a.value)throw new Error("Invalid arity value "+a.value);opTable[o.value]=new Operator(()=>{t.evaluate(r.value)},a.value)}),"del-op":new Operator(({stack:e})=>{delete opTable[e.pop().value]}),store:new Operator(({stack:e})=>{const{val:t,name:r}=e.popArgs("val","name");memory[r.value]=t}),load:new Operator(({stack:e})=>memory[e.pop().value]),delete:new Operator(({stack:e})=>{delete memory[e.pop().value]}),pack:new Operator(({stack:e})=>{const t=e.popAll();return new Token({type:"symbol",value:t.map(e=>e.serialize()).join(" ")})}),eval:new Operator(({stack:e,interpreter:t})=>{t.evaluate(e.pop().value)}),js:new Operator(({stack:stack})=>{const str=stack.pop(),evaluate=code=>function(code){return eval(code)}.call({stack:stack,push:(...e)=>{e.forEach(e=>stack.push(new Token({type:"symbol",value:e})))},pop:()=>stack.pop().value},code),result=evaluate(str.value);void 0!==result&&stack.push(new Token({type:"symbol",value:result}))})},ruleSet=[[/\s+/,e=>{}],[/\/\/.*?$/m,e=>{}],[/\/\*+[^*]*\*+(?:[^/*][^*]*\*+)*\//,e=>{}],[/"((?:[^"\\]|\\.)*?)"/,e=>{const t=e[1].replace(/\\(.)/g,"$1");return new Token({type:"symbol",value:t})}],[/'([^\s']+)/,e=>new Token({type:"symbol",value:e[1]})],[/true|false/,e=>new Token({type:"symbol",value:"true"===e[0]})],[/[+-]?\d*\.?[0-9]+([eE][+-]?\d+)?/,e=>new Token({type:"symbol",value:Number.parseFloat(e[0])})],[/\S+/,e=>{const t=e[0];return new Token(t in opTable?{type:"operator",value:t}:{type:"symbol",value:t})}]],tokenizer=new Tokenizer(ruleSet),interpreter=new Interpreter(opTable,tokenizer),result=interpreter.evaluate(input);return result?{value:result.value,interpreter:interpreter,memory:memory}:{value:void 0,interpreter:interpreter,memory:memory}}exports.Interpreter=Interpreter,exports.run=run}]);
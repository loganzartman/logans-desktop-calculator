!function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(1);window.addEventListener("load",(function(){document.getElementById("input").addEventListener("keyup",e=>{(e=>{const t=document.getElementById("input"),r=document.getElementById("registers"),o=document.getElementById("stack");try{const e=n.run(t.value);o.innerHTML="",e.interpreter.stack.reverse().forEach(e=>{const t=document.createElement("div");t.textContent=e.value,t.classList.add("stack-item"),t.classList.add("token--"+typeof e.value),o.appendChild(t)}),r.innerHTML="",Object.keys(e.memory).forEach(t=>{const n=document.createElement("div");n.className="register";const o=document.createElement("div");o.className="register-label",o.textContent=""+t;const a=document.createElement("div");a.classList.add("register-value"),a.classList.add("token--"+typeof e.memory[t].value),a.textContent=""+e.memory[t].value,n.appendChild(o),n.appendChild(a),r.appendChild(n)})}catch(e){o.textContent=e}})()},!1)}),!1)},function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.run=exports.Interpreter=exports.Operator=exports.Tokenizer=exports.Token=exports.UnknownOperator=exports.InputExhausted=void 0;class InputExhausted extends Error{}exports.InputExhausted=InputExhausted;class UnknownOperator extends Error{}function isIterable(e){return e&&Symbol.iterator in e}exports.UnknownOperator=UnknownOperator;class Token{constructor({type:e,value:t}){this.type=e,this.value=t}clone(){const{type:e,value:t}=this;return new Token({type:e,value:t})}}exports.Token=Token;class Tokenizer{constructor(e){this.ruleSet=e}tokenizeParen(e){let t=0,r=0;do{if(r>=e.length)throw new Error("Unmatched parentheses");"("===e[r]?++t:")"===e[r]&&--t,++r}while(t>0);const n=e.slice(1,r-1);return[new Token({type:"symbol",value:n}),e.slice(r)]}*tokenize(e){for(;e.length>0;){if("("===e[0]){const[t,r]=this.tokenizeParen(e);e=r,yield t;continue}let t=0,r=null,n=null;for(let[o,a]of this.ruleSet){const u=o.exec(e);if(!u||0!==u.index)continue;const l=u[0].length;l>t&&(t=l,r=u,n=a)}if(0===t)throw new Error("Unrecognized grammar starting here: "+e.slice(0,32));const o=n(r);o&&(yield o),e=e.slice(t)}}}exports.Tokenizer=Tokenizer;class Operator{constructor(e,t=!1,r=e.length){this.func=e,this.arity=r,this.rest=t,this.interpreter=null}collectArgs(e,t){const r=[];for(let n=0;n<this.arity;++n){if(0===e.stack.length)throw new Error(`Expected ${this.arity} operands for operator "${t}"`);r.push(e.stack.pop())}if(this.rest)for(;e.stack.length>0;)r.push(e.stack.pop());return r}pushResult(e,t){isIterable(t)?e.stack.push(...t):t&&e.stack.push(t)}invoke(e,t){const r=this.collectArgs(e,t);this.interpreter=e;const n=this.func.apply(this,r);return this.interpreter=null,this.pushResult(e,n),n}}exports.Operator=Operator;class Interpreter{constructor(e,t){this.stack=[],this.opTable=e,this.tokenizer=t}getOp(e){if(e in this.opTable)return this.opTable[e];throw new Error(`"${e}" is not an operator`)}evaluate(e){const t=this.tokenizer.tokenize(e);for(let e of t)if("symbol"===e.type&&this.stack.push(e),"operator"===e.type){this.getOp(e.value).invoke(this,e.value)}if(0!==this.stack.length)return this.stack[this.stack.length-1]}}function run(input){const memory={},valueOp=e=>new Operator((...t)=>new Token({type:"symbol",value:e(...t.reverse())}),!1,e.length),opTable={"+":valueOp((e,t)=>e.value+t.value),"-":valueOp((e,t)=>e.value-t.value),"*":valueOp((e,t)=>e.value*t.value),"/":valueOp((e,t)=>e.value/t.value),"^":valueOp((e,t)=>e.value**t.value),"%":valueOp((e,t)=>e.value%t.value),xor:valueOp((e,t)=>e.value^t.value),"==":valueOp((e,t)=>e.value===t.value),"<":valueOp((e,t)=>e.value<t.value),">":valueOp((e,t)=>e.value>t.value),"<=":valueOp((e,t)=>e.value<=t.value),">=":valueOp((e,t)=>e.value>=t.value),not:valueOp(e=>!e.value),and:valueOp((e,t)=>e.value&&t.value),or:valueOp((e,t)=>e.value||t.value),if:new Operator((function(e,t,r){const n=this.interpreter.evaluate(r.value);this.interpreter.stack.pop(),n&&n.value?this.interpreter.evaluate(t.value):this.interpreter.evaluate(e.value)})),print:new Operator(e=>{console.log(e.value)}),dup:new Operator(e=>[e,e.clone()]),swap:new Operator((e,t)=>[e,t]),pop:new Operator(e=>{}),clear:new Operator((...e)=>{},!0),reduce:new Operator((function(e,t,...r){const n=this.interpreter.getOp(e.value);if(2!==n.arity)throw new Error(`A reduce operator must accept 2 operands; "${e.value}" requires ${n.arity}`);this.interpreter.stack.push(t);for(let t of r){this.interpreter.stack.push(t);if(isIterable(n.invoke(this.interpreter,e.value)))throw new Error(`Reduce operator "${e.value}" produced more than one return value`)}return this.interpreter.stack.pop()}),!0),map:new Operator((function(e,...t){const r=this.interpreter.getOp(e.value);if(1!==r.arity)throw new Error(`A map operator must accept 1 operand; "${e.value}" requires ${r.arity}`);for(;t.length>0;){const n=t.pop();this.interpreter.stack.push(n);if(isIterable(r.invoke(this.interpreter,e.value)))throw new Error(`Map operator "${e.value}" produced more than one return value`)}return this.interpreter.stack.pop()}),!0),filter:new Operator((function(e,...t){const r=this.interpreter.getOp(e.value);if(1!==r.arity)throw new Error(`A filter operator must accept 1 operand; "${e.value}" requires ${r.arity}`);for(;t.length>0;){const n=t.pop();this.interpreter.stack.push(n),r.invoke(this.interpreter,e.value);const o=this.interpreter.stack.pop();if(isIterable(o))throw new Error(`Filter operator "${e.value}" produced more than one return value`);o.value&&this.interpreter.stack.push(n)}return this.interpreter.stack.pop()}),!0),range:new Operator((function*(e,t,r){if("number"!=typeof r.value||"number"!=typeof t.value||"number"!=typeof e.value)throw new Error("range operator expects numerical arguments");const n=Math.sign(t.value-r.value),o=Math.abs(t.value-r.value)/e.value;let a=r.value;for(let t=0;t<o;++t)yield new Token({type:"symbol",value:a}),a+=n*e.value})),"alias-op":new Operator((e,t)=>{opTable[e.value]=opTable[t.value]}),"define-op":new Operator((e,t,r)=>{opTable[r.value]=new Operator((function(...t){this.interpreter.stack.push(...t),this.interpreter.evaluate(e.value)}),!1,t.value)}),"del-op":new Operator(e=>{delete opTable[e.value]}),store:new Operator((e,t)=>{memory[e.value]=t}),load:new Operator(e=>memory[e.value]),delete:new Operator(e=>{delete memory[e.value]}),pack:new Operator((function(){const e=new Token({type:"symbol",value:this.interpreter.stack.map(e=>{const t=e.value;return"string"==typeof t?`(${t})`:""+t}).join(" ")});for(;this.interpreter.stack.length;)this.interpreter.stack.pop();return e})),eval:new Operator((function(e){this.interpreter.evaluate(e.value)})),js:new Operator((function(str){const evaluate=code=>function(code){return eval(code)}.call({stack:this.interpreter.stack,push:e=>{this.interpreter.stack.push(new Token({type:"symbol",value:e}))},pop:()=>this.interpreter.stack.pop().value},code),result=evaluate(str.value);void 0!==result&&this.interpreter.stack.push(new Token({type:"symbol",value:result}))}))},ruleSet=[[/\s+/,e=>{}],[/\/\/.*?$/m,e=>{}],[/\*+[^*]*\*+(?:[^/*][^*]*\*+)*/,e=>{}],[/"((?:[^"\\]|\\.)*?)"/,e=>{const t=e[1].replace(/\\(.)/g,"$1");return new Token({type:"symbol",value:t})}],[/'([^\s']+)/,e=>new Token({type:"symbol",value:e[1]})],[/true|false/,e=>new Token({type:"symbol",value:"true"===e[0]})],[/[+-]?\d*\.?[0-9]+([eE][+-]?\d+)?/,e=>new Token({type:"symbol",value:Number.parseFloat(e[0])})],[/\S+/,e=>{const t=e[0];return new Token(t in opTable?{type:"operator",value:t}:{type:"symbol",value:t})}]],tokenizer=new Tokenizer(ruleSet),interpreter=new Interpreter(opTable,tokenizer),result=interpreter.evaluate(input);return result?{value:result.value,interpreter:interpreter,memory:memory}:{value:void 0,interpreter:interpreter,memory:memory}}exports.Interpreter=Interpreter,exports.run=run}]);
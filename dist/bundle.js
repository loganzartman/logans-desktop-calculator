!function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(1);window.addEventListener("load",(function(){document.getElementById("input").addEventListener("keyup",e=>{(e=>{const t=document.getElementById("input"),r=document.getElementById("registers"),o=document.getElementById("stack");try{const e=n.run(t.value);o.innerHTML="",e.interpreter.stack.reverse().forEach(e=>{const t=document.createElement("div");t.textContent=e.value,t.classList.add("stack-item"),t.classList.add("token--"+typeof e.value),o.appendChild(t)}),r.innerHTML="",Object.keys(e.memory).forEach(t=>{const n=document.createElement("div");n.className="register";const o=document.createElement("div");o.className="register-label",o.textContent=""+t;const a=document.createElement("div");a.classList.add("register-value"),a.classList.add("token--"+typeof e.memory[t].value),a.textContent=""+e.memory[t].value,n.appendChild(o),n.appendChild(a),r.appendChild(n)})}catch(e){o.textContent=e}})()},!1)}),!1)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.run=t.Interpreter=t.Operator=t.Tokenizer=t.Token=t.UnknownOperator=t.InputExhausted=void 0;class n extends Error{}t.InputExhausted=n;class o extends Error{}function a(e){return e&&Symbol.iterator in e}t.UnknownOperator=o;class u{constructor({type:e,value:t}){this.type=e,this.value=t}clone(){const{type:e,value:t}=this;return new u({type:e,value:t})}}t.Token=u;class s{constructor(e){this.ruleSet=e}tokenizeParen(e){let t=0,r=0;do{if(r>=e.length)throw new Error("Unmatched parentheses");"("===e[r]?++t:")"===e[r]&&--t,++r}while(t>0);const n=e.slice(1,r-1);return[new u({type:"symbol",value:n}),e.slice(r)]}*tokenize(e){for(;e.length>0;){if("("===e[0]){const[t,r]=this.tokenizeParen(e);e=r,yield t;continue}let t=0,r=null,n=null;for(let[o,a]of this.ruleSet){const u=o.exec(e);if(!u||0!==u.index)continue;const s=u[0].length;s>t&&(t=s,r=u,n=a)}if(0===t)throw new Error("Unrecognized grammar starting here: "+e.slice(0,32));const o=n(r);o&&(yield o),e=e.slice(t)}}}t.Tokenizer=s;class l{constructor(e,t=!1,r=e.length){this.func=e,this.arity=r,this.rest=t,this.interpreter=null}collectArgs(e,t){const r=[];for(let n=0;n<this.arity;++n){if(0===e.stack.length)throw new Error(`Expected ${this.arity} operands for operator "${t}"`);r.push(e.stack.pop())}if(this.rest)for(;e.stack.length>0;)r.push(e.stack.pop());return r}pushResult(e,t){a(t)?e.stack.push(...t):t&&e.stack.push(t)}invoke(e,t){const r=this.collectArgs(e,t);this.interpreter=e;const n=this.func.apply(this,r);return this.interpreter=null,this.pushResult(e,n),n}}t.Operator=l;class i{constructor(e,t){this.stack=[],this.opTable=e,this.tokenizer=t}getOp(e){if(e in this.opTable)return this.opTable[e];throw new Error(`"${e}" is not an operator`)}evaluate(e){const t=this.tokenizer.tokenize(e);for(let e of t)if("symbol"===e.type&&this.stack.push(e),"operator"===e.type){this.getOp(e.value).invoke(this,e.value)}if(0!==this.stack.length)return this.stack[this.stack.length-1]}}t.Interpreter=i,t.run=function(e){const t={},r=e=>new l((...t)=>new u({type:"symbol",value:e(...t.reverse())}),!1,e.length),n={"+":r((e,t)=>e.value+t.value),"-":r((e,t)=>e.value-t.value),"*":r((e,t)=>e.value*t.value),"/":r((e,t)=>e.value/t.value),"^":r((e,t)=>e.value**t.value),"%":r((e,t)=>e.value%t.value),xor:r((e,t)=>e.value^t.value),"==":r((e,t)=>e.value===t.value),"<":r((e,t)=>e.value<t.value),">":r((e,t)=>e.value>t.value),"<=":r((e,t)=>e.value<=t.value),">=":r((e,t)=>e.value>=t.value),not:r(e=>!e.value),and:r((e,t)=>e.value&&t.value),or:r((e,t)=>e.value||t.value),if:new l((function(e,t,r){const n=this.interpreter.evaluate(e.value);this.interpreter.stack.pop(),n&&n.value?this.interpreter.evaluate(t.value):this.interpreter.evaluate(r.value)})),print:new l(e=>{console.log(e.value)}),dup:new l(e=>[e,e.clone()]),swap:new l((e,t)=>[e,t]),pop:new l(e=>{}),clear:new l((...e)=>{},!0),reduce:new l((function(e,t,...r){const n=this.interpreter.getOp(e.value);if(2!==n.arity)throw new Error(`A reduce operator must accept 2 operands; "${e.value}" requires ${n.arity}`);this.interpreter.stack.push(t);for(let t of r){this.interpreter.stack.push(t);if(a(n.invoke(this.interpreter,e.value)))throw new Error(`Reduce operator "${e.value}" produced more than one return value`)}return this.interpreter.stack.pop()}),!0),map:new l((function(e,...t){const r=this.interpreter.getOp(e.value);if(1!==r.arity)throw new Error(`A map operator must accept 1 operand; "${e.value}" requires ${r.arity}`);for(;t.length>0;){const n=t.pop();this.interpreter.stack.push(n);if(a(r.invoke(this.interpreter,e.value)))throw new Error(`Map operator "${e.value}" produced more than one return value`)}return this.interpreter.stack.pop()}),!0),filter:new l((function(e,...t){const r=this.interpreter.getOp(e.value);if(1!==r.arity)throw new Error(`A filter operator must accept 1 operand; "${e.value}" requires ${r.arity}`);for(;t.length>0;){const n=t.pop();this.interpreter.stack.push(n);const o=r.invoke(this.interpreter,e.value);if(this.interpreter.stack.pop(),this.interpreter.stack.pop(),a(o))throw new Error(`Filter operator "${e.value}" produced more than one return value`);o.value&&this.interpreter.stack.push(n),console.log(o)}return this.interpreter.stack.pop()}),!0),range:new l((function*(e,t,r){if("number"!=typeof e.value||"number"!=typeof t.value||"number"!=typeof r.value)throw new Error("range operator expects numerical arguments");const n=Math.sign(t.value-e.value),o=Math.abs(t.value-e.value)/r.value;let a=e.value;for(let e=0;e<o;++e)yield new u({type:"symbol",value:a}),a+=n*r.value})),"alias-op":new l((e,t)=>{n[e.value]=n[t.value]}),"define-op":new l((e,t,r)=>{n[r.value]=new l((function(...t){this.interpreter.stack.push(...t),this.interpreter.evaluate(e.value);const r=this.interpreter.stack.length;return r>0?this.interpreter.stack[r-1]:void 0}),!1,t.value)}),"del-op":new l(e=>{delete n[e.value]}),store:new l((e,r)=>{t[e.value]=r}),load:new l(e=>t[e.value]),delete:new l(e=>{delete t[e.value]}),pack:new l((function(){const e=new u({type:"symbol",value:this.interpreter.stack.map(e=>""+e.value).join(" ")});for(;this.interpreter.stack.length;)this.interpreter.stack.pop();return e})),eval:new l((function(e){this.interpreter.evaluate(e.value)}))},o=new s([[/\s+/,e=>{}],[/\/\/.*?$/m,e=>{}],[/\*+[^*]*\*+(?:[^/*][^*]*\*+)*/,e=>{}],[/("|')((?:[^\1\\]|\\.)*?)\1/,e=>{const t=e[2].replace(/\\(.)/g,"$1");return new u({type:"symbol",value:t})}],[/true|false/,e=>new u({type:"symbol",value:"true"===e[0]})],[/[+-]?\d*\.?[0-9]+([eE][+-]?\d+)?/,e=>new u({type:"symbol",value:Number.parseFloat(e[0])})],[/\S+/,e=>{const t=e[0];return new u(t in n?{type:"operator",value:t}:{type:"symbol",value:t})}]]),p=new i(n,o),c=p.evaluate(e);return c?{value:c.value,interpreter:p,memory:t}:{value:void 0,interpreter:p,memory:t}}}]);